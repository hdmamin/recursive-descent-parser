8/6/25 wed
----------
debugging higher order functions
(start with current env, moving downwards moves into further removed parents)

n
# empty
f, count, n
global scope: various funcs
# parent=None

----
Issue
- seems like the empty env is the one attached to the closure (outer func) and SHOULD have just a 'min' var defined
- so basically, we should be defining a var in that env when we CREATED the filter by calling the outer func. But apparently that's not happening, OR is not persisting.
- update: I *think* the empty env is actually corresponding to a while block (though would if not create a block too? maybe not). And then current_env (top row) is for the function call f(n), i.e. greaterThanX(0). So maybe mentally I've kind of been modeling envs as a linked list but it's really more of a tree, and the env where we set min=55 is in some leaf node we're not traversing.
	- another framing: maybe envs are kind of ephemeral and so we need to do something different/additional to bind args to funcs?

8/12/25 tues
------------
trying to understand what's happening with closures
-when we execute the inner func, I notice we set i twice. First with declaration=True, then False.
-I believe the first of those calls is happening inside Interpreter.new_env() bc LoxFunction.evaluate unpacks nonlocal_env.state into new_env creation call.
	-somewhat oddly, this also means we define the inner func itself in its nonlocal env when executing it - maybe this is fine, but does feel a little strange.
-I think this means that when we later call update_state to increment i, we encounter i in the current state and simply update it there, when we really want to update it in the nonlocal env's state.
-so we need to NOT set nonlocal env vars in the new func env itself.
-however, we're already passing in definition_env as the parent. And we do need to attach the nonlocal env somehow.
	-can we maybe view nonlocal env as the child of definition_env? If so maybe we can enforce that chain of envs?

9/1/25 mon
----------
debugging why closure test case is not working
-we get two var lookups per call, one for the Assign (initially thought there might be two here but apparently not) and one for the Print
-first two func calls look good. we reference the global state, that var gets incremented between the two lookups, the second lookup reflects the incremented value
-third call, now we have a new count var in the block env where makeCounter was defined. So I THINK what is happening is we end up incrementing that one but printing the global? Not sure why yet.
-Also notice read_state_at ends up calling read_state which can traverse up through parents if var is not found. So I think we need to allow caller to disable that behavior. Basically, I think we're not finding count in the current env so we just traverse up automatically and hit the enclosing block env.
	-initially remembered chatgpt as claiming depth=0 was correct for count, not sure how that is supposed to work. But thinking back, actually we just said all vars that had some assigned depth had depth=0, but I think depth=None was actually correct here. So we should hit that if condition in lexer.py and jump straight to the global count. Maybe that explains why we print that at the end. So mystery becomes, why does the var increment step (I'm predicting) affect the block env?
	-update: not exactly what I thought. Somehow we update the block env count from 0 straight to 3, but must be printing the global env still which is 2. So I'm thinking the increment expression first retrieves the global var of 2, adds 1 to get 3, and assigns that back to the block env. And then in print we get the unchanged global. But really this function call should not be changing the block env at all.
-guessing this is maybe tied to the function call evaluate logic where I pass in something like 
```
kwargs.get("env") or self.definition_env
```
UPDATE: it's actually
```
self.nonlocal_env or self.func.definition_env
```
-And I confirmed we are consistently using nonlocal_env (seems like this should be the env created by makeCounter body block?)
-weirdly, current and parent env states are both showing up as empty? might be printing the wrong thing in debugging lines?
	-also notice neither current_env and parent_env are the nonlocal env. Aha, looks like current.parent.parent is nonlocal env. Somehwhat to my surprise, definition_env is global_env (that seems wrong? Looks like we set that based on what the current interpreter env is at func definition time which seems reasonable enough to me but idk. Recall adjusting this env logic quite carefully to get nested funcs and closures working pre resolution stage. ðŸ¤”)

9/2/25 tues
-----------
```
// Variables declared in an outer scope should be
// accessible inside inner scopes, but not the
// other way around
{
  var foo = "outer foo";
  var baz = "outer baz";
  {
    foo = "modified foo";
    var baz = "inner baz";
    print foo;
    print baz;
  }
  print foo;
  print baz;
}
print foo;
```

findings
-the outer vars NEVER get modified here. This is correct behavior for baz, which gets redefined, but not for foo, which is just an assign call.
-foo has depth 0 in assign call which I think is why we update inner block. I see during resolution we do resolve foo to both depth 1 and 0. So I think this reflects the issue of using str keys in locals. Looks like we do need to change that ðŸ˜¬.

---
// This program uses for loops and block scopes
// to print the updates to the same variable
var baz = "after";
{
  var baz = "before";

  for (var baz = 0; baz < 1; baz = baz + 1) {
    print baz;
    var baz = -1;
    print baz;
  }
}

{
  for (var baz = 0; baz > 0; baz = baz + 1) {}

  var baz = "after";
  print baz;

  for (baz = 0; baz < 1; baz = baz + 1) {
    print baz;
  }
}

9/14/25 sun
-----------
investigating broken instance methods

Undefined variable Foo when a method tries to reference Foo (error msg corresponds to the line where Foo is referenced in the method, but it's only triggered if we call that method. So method execution vs definition seems to be the issue, at least the point where the error gets raised.)
Error goes away if we move the class out of a block.

-definition_env is the same as the global_env but we expect it to be the block env
-execution env is child of the "this" env which is child of definition env. All this is correct I believe, it's just that the definition env is wrong here. 
-definition_env is defined based on what the env is at Function.init time, which seems expected (recall function is basically functionDeclaration).
-Block.evaluate creates a new env. But I think exec order goes:
	Block.init
	Function.init
	Block.evaluate
	Function.evaluate
and Function.definition_env is set in init.

9/24/25 wed
-----------
debugging wrong error message for super not followed by period
-we reach block which calls declaration()
	-we reach expression_statement. The first expression() call is what raises an error and never completes.
	-zooming into expression call, we eventually reach primary which triggers the error (Super clause with intended error message)
	-this seemingly triggers declaration -> synchronize -> declaration -> synchronize
-and only the last synchronize error gets raised, whereas we want the first error message

-declaration is called to parse class (B). And in the course of parsing B we get a nested declaration call to parse super or maybe method(). and so I think we want to only raise the error from the innermost synchronize call but currently we're raising all of them, and this seemingly results in only the last one (?) actually getting raised.

enter outer declaration 0
enter inner declaration 0
enter inner synchronize 0
exit inner synchronize 1
exit inner declaration 1
enter outer synchronize 1
exit outer synchronize 1
exit outer declaration 0

we want inner synchronize to execut
we do NOT want outer synchronize to execute
so seems like inner synchronize should trigger panic mode
and outer declaration should end it
but how do we know when we're in inner/outer for either? inner declaration will exit before inner synchronize, so declaration can't just always end panic mode
maybe coudl maintain some kind of queue of synchronize errors and only raise the first one? but still need to figure out when to clear it

notes to self for where I left off end of 9/24 wed:
		> error message is wrong. Can see we're hitting the correct one but it's somehow getting swallowed and only a later error is getting raised. Must be caught by some error handling or something? Need to investigate more. Remember to remove `custom_error=True` in `declaration else clause` if end up not using it.
		> update: made some progress diagnosing. Key is that the innermost synchronize is the only one we want to execute, but determining what the innermost one is is a bit tricky. See misct.txt notes, prob can ignore most but the enter/exit lines with expected depths is helpful. Need to either figure out logic to make that work (notice the last step makes the decrement rule quite tricky) or perhaps can accumulate some sort of of queue/stack of open calls and close them in parse except.
		> update 2: tried implementing that last idea of resetting depth in parse except, feels close but now getting inf loop of returning Nones - thinking exiting early from synchronize means that declaration is returning None now. Though now I notice it seems odd that previously, an error in the nested declaration call was not bubbling up to the outer one ðŸ¤”.
	-`make test_inheritance_w_jlox` all stages pass: 6/6
