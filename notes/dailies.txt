7/1/25 tues
-----------
[just wrote some quick notes to myself today, can switch to my more standard todo format going forward]
-got test repo cloned and `make test_control_flow_w_jlox` passes but 99% sure it's testing the codecrafters repo code (functions test also passes even though I haven't started that section yet). I think I either need to:
    -update makefile commands so CODECRAFTERS_REPOSITORY_DIR points to my repo (though I don't have different chapter subdirs), OR
    -figure out how to run without makefile? test repo readme doesn't make any mention of those so maybe that's not the intended path

7/2/25 wed
----------
X -set up new remote repo
    X -confirm why currently set to so many (see ls-remote output in pane below)
    X -create new repo
    X -update remote pointer
    X -fix remote for test repo (accidentally changed this instead of my repo)
-get tests running using my source code vs book's. Either
    ~ -update makefile commands so CODECRAFTERS_REPOSITORY_DIR points to my repo (though I don't have different chapter subdirs), OR
        > updates: managed to access env var in makefile after export. Tests still seem to run against REPOSITORY_DIR (vs SUBMISSION_DIR) though, and if REPOSITORY_DIR is not provided, tester errors out even though submission_dir is provided. Next step seem s to be to try setting REPOSITORY_DIR as my path, perhaps SUBMISSION_DIR is not actually required?
    ! -figure out how to run without makefile? test repo readme doesn't make any mention of those so maybe that's not the intended path

7/3/25 thurs
------------
-get tests running using my source code
    -try updating REPOSITORY_DIR to point to my repo
        > if this isn't the fix, kinda stumped. Will need to re-assess based on error messages, not sure what next tact would be.
        X -update repo dir in makefile
        ~ -try running a level I have implemented (this should pass)
            > findings: your_program.sh is being executed from test repo root, so it can't find app module. Need to either chdir inside it or update the python path or something.
        -try running a level I have NOT implemented (this should fail)

7/4/25 fri
----------
X -get tests running using my source code
    X -try updating REPOSITORY_DIR to point to my repo
        > findings: your_program.sh is being executed from test repo root, so it can't find app module. Need to either chdir inside it or update the python path or something.
        X -maybe create config/shell script setting env vars somewhere? (Realized they're not persisting past the current sesion with my current method so everything is a bit fragile atm)
            > only need to set one actually, just do this once at start of makefile.
        X -try updating python path in your_program.sh to always include the right path (maybe hardcode?)
        ~ -try running a level I have implemented (this should pass)
            > technically failed but I think that's revealing a new bug 🫣, it actually is running my code!
        X -try running a level I have NOT implemented (this should fail)

7/5/25 sat
----------
-move tests into my main repo
    X -decide desired structure (test repo seems to want to copy interpreter implementation into it, but I think it probably makes more sense to copy test repo into main repo (in new tests subdir))
    X -copy files over
    X -update make commands if necessary
    -update readme to remind me how to run tests
-check that I can still run your_program.sh directly
-fix all broken stage(s)
    -fix parsing stage
    -check if other stages pass
-return to work on syntactic errors substage

7/6/25 sun
----------
X -move tests into my main repo
    X -update readme to remind me how to run tests
-check that I can still run your_program.sh directly
-fix all broken stage(s)
    -fix parsing stage ("(23 +)" now times out; check activity monitor for python3.10 memory leaks)
    -check if other stages pass
-return to work on syntactic errors substage

7/7/25 mon
----------
X -check that I can still run your_program.sh directly
    > Also updated makefile with wrappers for run etc. Tested all and they work for a simple test case, though the parsing bug for "(23 +)" is of course still unresolved.
-fix all broken stage(s)
    -fix parsing stage ("(23 +)" now times out; check activity monitor for python3.10 memory leaks)
    -check if other stages pass
-return to work on syntactic errors substage

7/8/25 tues
-----------
-fix broken stage(s)
    X -scanning stage: ("(23 +)" now times out; check activity monitor for python3.10 memory leaks)
    -check if other stages pass
        X -parsing
        X -evaluation
        -statements
            > fiddled with the above couple stages a bit and got them working, but statements is failing to load test cases for some reason. Seems to be tied to paths (recall I moved everything into tests subdir so I could use one repo) but not sure why this is only impacting one command? Maybe can set env var manually and/or use cursor chat instructions to debug that one function.
-return to work on syntactic errors substage

7/9/25 wed
----------
-fix broken stage(s)
    -fix stage: test_statements
        > Seems to be tied to paths (recall I moved everything into tests subdir so I could use one repo) but not sure why this is only impacting one command?
        X -try testing GetTestCasesForCurrentStage using cursor chat instructions
        X -and/or try setting TESTER_DIR env var in makefile?
        X -test_statements runs
        -test_statements passes
    X -confirm scanning/parsing/evaluation commands still pass
-return to work on syntactic errors substage

7/10/25 thurs
-------------
-fix broken stage(s)
    > current test case produces errors in parse mode. Weirdly evaluate still works, but run only seems to execute the first of 3 prints.
    X -get current test case working in:
        X -parse mode
        X -evaluate mode
        X -run mode
    X -"make test_statements_w_jlox" passes
    X -confirm others still pass still pass afterwards:
        X -scanning
        X -parsing
        X -evaluation
~ -return to work on syntactic errors substage
    X -"make test_control_flow_w_jlox" passes
    > weird, this somehow passes now...I guess I did make some other changes in getting other changes to pass so it's plausible those fixed something? Also possible codecrafters sample test cases in UI were wrong/broken and maybe I never got around to testing the whole test suite bc I thought I was stuck when I wasn't?

7/11/25 fri
-----------
X -return to work on syntactic errors substage
    > recall control flow test suite passed, to my surprise. Curious if the test cases on the site give the expected outputs.
    X -check if test cases in codecrafters UI pass
        > still slightly different error phrasing but the behavior seems correct and the actual test suite passes so /shrug.
-start "native functions" stage
    ~ -new call cls
        > still need to flesh out evaluate a bit
    X -new call method + integrate into existing methods
    -new python clock function
    -set clock as a var in the global env upfront
    -first test case passes
    -other UI test cases pass
    -makefile test suite passes

7/12/25 sat
-----------
-start "native functions" stage
    X -refactoring to avoid circular imports
    ~ -new python clock function
    ~ -set clock as a var in the global env upfront
        > some progress but still need to figure out how func execution is evaluated. Understanding is a little muddled atm, see comments in interpreter.py.
    -finish call.evaluate
    -first test case passes
    -other UI test cases pass
    -makefile test suite passes

7/13/25 sun
-----------
-low effort tasks:
    X -cleanup some todos
    -add more low effort task bullets
-"native functions" stage
    > Need to figure out how func execution should be evaluated. Understanding is a little muddled atm, see comments in interpreter.py.
    -confirm (via book/chat) distinction between Callable and Call, what should each's evaluate return?
    -finish Callable expr (if necessary?)
    -finish call.evaluate
    -first test case passes
    -other UI test cases pass
    -makefile test suite passes

7/14/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
-"native functions" stage
    > Need to figure out how func execution should be evaluated. Understanding is a little muddled atm, see comments in interpreter.py.
    > update: some good progress, tried running a simple test case but circular import is the first issue to resolve.
    ! -confirm (via book/chat) distinction between Callable and Call, what should each's evaluate return?
    X -finish Callable expr (if necessary?)
    X -finish call.evaluate
    -first test case passes
    -other UI test cases pass
    -makefile test suite passes

7/15/25 tues
------------
-low effort tasks:
    -add more low effort task bullets
-"native functions" stage
    > tried running a simple test case but circular import is the first issue to resolve.
    X -resolve circular imports issue
        X -diagnose
            > lexer module imports interpreter to make Token.evaluate work. interpreter module imports Token (and TokenTypes etc). TokenTypes is used extensively, Token is only for type hints.
        X -refactor
            > non-trivial, ended up using a sys.modules hack instead.
    ~ -first test case passes
        > executes but noticing now that UI shows ints and mine are floats. Also need to confirm if magnitudes are correct, like are we counting from the right datetime.
    -other UI test cases pass
    -makefile test suite passes

7/16/25 wed
-----------
-low effort tasks:
    -add more low effort task bullets
X -"native functions" stage
    X -first test case passes
        > executes but noticing now that UI shows ints and mine are floats. Also need to confirm if magnitudes are correct, like are we counting from the right datetime.
        X -convert clock to return int (check book for guidance on what exactly this should do, do we just need to round or am I computing wrong units or something?)
        X -value is correct (idk how to confirm that though? Since it should be a function of when we run it)
            > did some napkin math and changed clock implementation, perf_counter is not actually what we wanted.
    X -other UI test cases pass
    X -makefile test suite passes (just stage 1 of functions)


7/17/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
-new stage: functions without arguments
	~ -skim book section 10.3
	~ -implement
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/18/25 fri
-----------
-low effort tasks:
    -add more low effort task bullets
-new stage: functions without arguments
	X -refactor: mv statements -> interp module
		> needed statements and expressions in the same module for some inheritance stuff I think
	-flesh out parsing logic in function_declaration
	-flesh out Function.evaluate
	-is FunctionDeclaration actually needed? Maybe just Function is sufficient?
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/19/25 sat
-----------
-low effort tasks:
	X -little bit of todo cleanup
    -add more low effort task bullets
-new stage: functions without arguments
	-flesh out parsing logic in function_declaration
	-flesh out Function.evaluate
	-is FunctionDeclaration actually needed? Maybe just Function is sufficient?
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/20/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
-new stage: functions without arguments
	~ -flesh out parsing logic in Parser.function_declaration
	-flesh out Function.evaluate
	-is FunctionDeclaration actually needed? Maybe just Function is sufficient?
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/21/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
-new stage: functions without arguments
	~ -flesh out parsing logic in Parser.function_declaration: flesh out FunctionDeclaration or switch to Function
	~ -flesh out Function.evaluate
		> seems like we're largely supposed to delegate to LoxFunction? Maybe I'll need to add more stuff later, idk.
	X -is FunctionDeclaration actually needed? Maybe just Function is sufficient?
		> still kidna fuzzy on this but seems like yes, both are needed, Function is for parsing-time definition and LoxFunction is for runtime execution.
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/22/25 tues
------------
-low effort tasks:
    -add more low effort task bullets
-new stage: functions without arguments
	-flesh out FunctionDeclaration.evaluate
		~ -figure out how to make args available in env
			> left some notes in file, basically hoping to let Interpreter.new_env set kwargs and then let loxfunction pass kwargs to block. But still some details to figure out.
	-flesh out Function.evaluate if necessary
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/23/25 wed
-----------
-low effort tasks:
	X -clean up imports
		> running revealed some imports that broke since I last ran, cleaned them up and also removed some now unused ones
    -add more low effort task bullets
-new stage: functions without arguments
	~ -flesh out FunctionDeclaration.evaluate
		~ -figure out how to make args available in env
			> left some notes in file, basically hoping to let Interpreter.new_env set kwargs and then let loxfunction pass kwargs to block. But still some details to figure out.
			> some decent progress, updated new_env method and Block and LoxFunction so that setting args *should* in theory work, minus some pending bugs. But haven't gotten far enough yet to confirm for sure that my method works.
	X -flesh out Function.evaluate if necessary
		> ended up putting this logic in LoxFunction.evaluate bc I think that's what the book did.
	-UI test cases pass
	-makefile test suite passes (stages 1-2 of functions)

7/24/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
X -new stage: functions without arguments
	X -debug current test case: various parsing errors (I think start in parser module, function_declaration method)
	X -UI test cases pass
	X -makefile test suite passes (stages 1-2 of functions)


7/25/25 fri
-----------
-low effort tasks:
    -add more low effort task bullets
X -new stage #60: functions with args
	X -skim codecrafters + book section to understand what we need to implement
	X -ui tests pass
	X -`make test_functions_w_jlox` stages 1-3 pass

7/26/25 sat
-----------
-low effort tasks:
    -add more low effort task bullets
-new stage #61: syntax errors
	X -skim codecrafters + book section to understand what we need to implement
	-ui tests pass
		> 0 and 1 pass, 2 looks essentially right but exact error format/order is slightly different but in the past the actual makefile tests matched my way so maybe that's the case again? Will guess it's fine for now and return if make tests fail. 3 should raise the "expect left brace" error but currently raises generic "expect expression". 4 should catch missing comma but does not.
		-fix 3: should hit "expect left brace"
		-fix 4: should error on missing comma
			> solid progress, currently we're raising an error in the right place in function_declaration but synchronize is swallowing that and replacing with a new error. Need to figure out how to handle this without breaking old behavior.
	-`make test_functions_w_jlox` stages 1-4 pass

7/27/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
X -new stage #61: syntax errors
	X -ui tests pass
		X -fix 4: should error on missing comma
			> solid progress, currently we're raising an error in the right place in function_declaration but synchronize is swallowing that and replacing with a new error. Need to figure out how to handle this without breaking old behavior.
		X -fix 3: should hit "expect left brace"
	X -`make test_functions_w_jlox` stages 1-4 pass
	X -prev rounds' tests still pass
		X -scanning
		X -parsing
		X -evaluation
		X -statements
		X -control_flow

7/28/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
-new stage #62: return statements
	X -skim codecrafters + book to see what I need to implement
	~ -ui tests pass
		> some good progress, currently expression() call in statement is raising error. Started on a ReturnStatement class and adding new case to statement method.
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

7/29/25 tues
------------
-low effort tasks:
    -add more low effort task bullets
-stage #62: return statements
	-ui tests pass
		~ -flesh out parsing logic when hitting return token in statement (debug last if clause in statement())
			> progress: now parsing the func definition correctly but execution is None. Noticed the function call is getting parsed as Call() rather than LoxFunction (maybe this is desirable? Did seem weird to me that we need both). Need to dig into what Call does and whether we can merge it with LoxFunction or make the two play nicely together in some way. MIGHT also need to update Block.evaluate to deal with returns? Currently seems to return nothing.
		-do we need something special to handle case where no return statement?
		-confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

7/30/25 wed
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #62: return statements
	X -flesh out parsing logic when hitting return token in statement (debug last if clause in statement())
		> tues progress: now parsing the func definition correctly but execution is None. Noticed the function call is getting parsed as Call() rather than LoxFunction (maybe this is desirable? Did seem weird to me that we need both). Need to dig into what Call does and whether we can merge it with LoxFunction or make the two play nicely together in some way. MIGHT also need to update Block.evaluate to deal with returns? Currently seems to return nothing.
	! -do we need something special to handle case where no return statement?
		> don't think so, we will just return nil.
	-confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
	-ui tests pass
		X -0
		-1
			> no, recursion depth exceeded.
		-2
			> no, returning nil instead of 'ok'.
		X -3
		-4
			> no, few synax errors at end of func definition
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

7/31/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
-stage #62: return statements
	-confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
	-ui tests pass
		-1
			> no, recursion depth exceeded.
		-2
			> no, returning nil instead of 'ok'.
		X -4
			> no, few synax errors at end of func definition
            > update: fixed, prev weren't handling the "return;" case.
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/1/25 fri
----------
-low effort tasks:
    -add more low effort task bullets
-stage #62: return statements
	[WAIT until tests reveal a need] -confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
	-ui tests pass
		X -2
			> returning nil instead of 'ok'.
            > update: solution broke #4 but I fixed it, ReturnStatement.evaluate previously didn't need to do anything when return value=None but now it needs to raise error regardless.
		-1
			> recursion depth exceeded.
            > update: slightly different behavior now, it just silently hangs. Maybe stuck in some infinite while loop somewhere?
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/2/25 sat
----------
-low effort tasks:
    -add more low effort task bullets
-stage #62: return statements
	[WAIT until tests reveal a need] -confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
	-ui tests pass
		~ -1
            > just silently hangs. Maybe stuck in some infinite while loop somewhere?
            > update: code actually works but is very slow. Confirmed we are calling the base cases the correct number of times but for n>=4, we are doing too many recursive calls (see screenshot in previews for table of n_calls we expect). So we are timing out on the test case which uses a large n of 32. Need to dig deeper into these recursive calls to identify why we're getting more than expected.
	-`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/3/25 sun
----------
-low effort tasks:
    -add more low effort task bullets
X -stage #62: return statements
	! [WAIT until tests reveal a need] -confirm if I need a separate Return class from ReturnStatement? Seems odd but book maybe does this?
        > seems like no
	! -ui tests pass
		-1
            > code works but is very slow. Confirmed we are calling the base cases the correct number of times but for n>=4, we are doing too many recursive calls (see screenshot in previews for table of n_calls we expect). So we are timing out on the test case which uses a large n of 32. Need to dig deeper into these recursive calls to identify why we're getting more than expected.
        > update: hmmm, more debugging and n_calls actually DOES seem to match expected. And on a whim I ran actual test cases to see how far it gets and they pass, fibonacci func is called with n=10 instead of 32, though comments hint at this being 35 at one point. idk, I guess we'll return to this if/when it reveals itself as a problem? Afaict everything's behaving as expected otherwise.
	X -`make test_functions_w_jlox` stages 1-5 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
-stage #63: higher order functions
    -skim ui/book to see what I need to implement
	-ui tests pass
        X -1
        -2
            > found parsing error, function name with "return" in it is getting parsed to multiple tokens. May need to dive back into Trie logic 😬. (Looks like there are other errors too fwiw, tried removing all the trailing n's in names with return and still got a bunch of syntax/parsing errors.)
        -3
        -4
	-`make test_functions_w_jlox` stages 1-6 pass

8/4/25 mon
----------
-low effort tasks:
    -add more low effort task bullets
-stage #63: higher order functions
    ~ -skim ui/book to see what I need to implement
	-ui tests pass
        ~ -2
            > UPDATE: Realized reserved types need to be followed by a non alphanumeric char. I tried to add this logic in TokenType._default_longest_leading_substring but realized that only is used in longest_leading_substring call below I think, AFTER the token type is already inferred. So need to update infer_token_type itself OR perhaps compute both reserved and non-reserved candidates, compute substring for both, and then select the longest non-None substring.
        -3
        -4
	-`make test_functions_w_jlox` stages 1-6 pass

8/5/25 tues
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #63: higher order functions
	-ui tests pass
        X -2
            > reserved types need to be followed by a non alphanumeric char. I tried to add this logic in TokenType._default_longest_leading_substring but realized that only is used in longest_leading_substring call below I think, AFTER the token type is already inferred. So need to update infer_token_type itself OR perhaps compute both reserved and non-reserved candidates, compute substring for both, and then select the longest non-None substring.
			> UPDATE: lexing/tokenizing tentatively fixed now, but now surprisingly getting errors when evaluating/running. This occurs both when varnames contain keywords and when they don't.
			> UPDATE: prev update was mostly working, just forgot to update a couple refs. Seems good now!
        X -3
        ~ -4
			> undefined variable min, basically looks like outer scope params are not being exposed in inner scope.
	-`make test_functions_w_jlox` stages 1-6 pass

8/6/25 wed
----------
-low effort tasks:
    -add more low effort task bullets
	X -new notes dir
		> renamed notes.txt -> dailies.txt, added misc.txt for debugging notes
-stage #63: higher order functions
	-ui tests pass
        ~ -4
			> undefined variable min, basically looks like outer scope params are not being exposed in inner scope.
			> UPDATE: some notes in misc.txt. Think it's time to dive back in to the book to see if they provide guidance on implementation.
	-`make test_functions_w_jlox` stages 1-6 pass

8/7/25 thurs
------------
-low effort tasks:
    -add more low effort task bullets
-stage #63: higher order functions
	-ui tests pass
		X -reference book section (hoping for implementation tips, closure args are proving a bit tricky)
            > as an exercise, tried to design a solution first intuitively before reading. And it turned out to be basically exactly what he did! I should do this more.
        ~ -4
			> see notes in misc.txt re undefined arg in closure.
            > update: good progress, think I resolved the closure issue. But now encountering the problem that returning from a nested block does not cause us to return from the outer block. Need to figure out how to make this work for arbitrarily deep levels of nesting.
	-`make test_functions_w_jlox` stages 1-6 pass

8/8/25 fri
----------
-low effort tasks:
    -add more low effort task bullets
X -stage #63: higher order functions
	X -ui tests pass
        X -4
            > reminder: think I resolved the closure issue but now encountering the problem that returning from a nested block does not cause us to return from the outer block. Need to figure out how to make this work for arbitrarily deep levels of nesting.
	X -`make test_functions_w_jlox` stages 1-6 pass
	X -prev rounds' tests still pass
		X -scanning
		X -parsing
		X -evaluation
		X -statements
			> uh oh, statements and control_flow fail now. Lexing error, maybe tied to empty str?
			> update: yep, new leading_substring logic broke empty str lexing. Fixed now.
		X -control_flow

8/9/25 sat
----------
-low effort tasks:
    -add more low effort task bullets
X -stage #64: runtime errors
	X -skim ui/book to see what I need to implement
	X -ui tests pass
		> spent a lot of time on ridiculous metaclass, but kinda fun /shrug.
		X -0
		X -1
		X -2
		X -3
		X -4
	X -`make test_functions_w_jlox` stages 1-7 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/10/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #65: function scope (new stage!)
	-skim ui/book to see what I need to implement
	~ -ui tests pass
		X -0
		X -1
		X -2
		X -3
		-4
			> last 2 printed lines are wrong. Found this a bit brain exploding but I think the gist of it is: printBoth is defined such that it will always reference the global vars x and y. Creating and modifying vars inside our block does NOT modify the globals. So this has no impact on the func call at the end. In test case 1 (which initially seemed like inconsistent behavior with test case 4 to me), things only appear to work differently, what's really happening is the first print inside printAndModify prints the global val, the second prints the local val, and nothing in printAndModify modifies the global var (bit confusing name...). Uf we call print a after the func call, it's actually still 68.
	-`make test_functions_w_jlox` stages 1-8 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/11/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
X -stage #65: function scope (new stage!)
	X -skim ui/book to see what I need to implement
	X -ui tests pass
		X -4
			> last 2 printed lines are wrong. Found this a bit brain exploding but I think the gist of it is: printBoth is defined such that it will always reference the global vars x and y. Creating and modifying vars inside our block does NOT modify the globals. So this has no impact on the func call at the end. In test case 1 (which initially seemed like inconsistent behavior with test case 4 to me), things only appear to work differently, what's really happening is the first print inside printAndModify prints the global val, the second prints the local val, and nothing in printAndModify modifies the global var (bit confusing name...). If we call print a after the func call, it's actually still 68.
			> seems like we need to make our func check the global state before the parent/caller state. Think we prob need to set this as func definition time, so in Function.init or Function.evaluate? Or maybe in LoxFunction.evaluate, I need to actually execute in nonlocal_env itself vs passing its state to new_env? That doesn't seem quite right, maybe I need to allow passing a parent env to new_env and make new_env a child of nonlocal_env. UPDATE: nonlocal env is only used when writing closures I think, does not affect this case.
	X -`make test_functions_w_jlox` stages 1-8 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow

8/12/25 tues
------------
-low effort tasks:
    -add more low effort task bullets
X -stage #66: closures (new stage! last in functions section)
	! -skim ui/book to see what I need to implement
	X -ui tests pass
		X -0
		X -1
		X -2
		X -3
		X -4
	X -`make test_functions_w_jlox` stages 1-9 pass
	X -prev rounds' tests still pass
		X -scanning
		X -parsing
		X -evaluation
		X -statements
		X -control_flow

8/13/25 wed
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	~ -skim ui/book to see what I need to implement
		> still wrapping my head around intended behavior, seems like we're undoing all the work I just did in closures (which already felt like undoing the work I did for higher order funcs) :/
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/14/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	-skim ui/book to see what I need to implement
		> still wrapping my head around intended behavior, seems like we're undoing all the work I just did in closures (which already felt like undoing the work I did for higher order funcs) :/
		> read a bit more, still not really getting closer to figuring out how to approach this. Peeked at some future stages and I don't think skipping ahead even temporarily will work, need to barrel through.
		> learnings/realizations from today's chat: scope maps varname to boolean, not var value. Bool indicates whether the var has been initialized but not clear to me yet when vars are not initialized. Asked gpt for some pseudocode as an illustrative tool and seems like I will need to implement a new resolve() method for each statement/expr/decl subclass. That at least gives me some direction to fumble around in.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/15/25 fri
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	~ -skim ui/book to see what I need to implement
		> still wrapping my head around intended behavior, seems like we're undoing all the work I just did in closures (which already felt like undoing the work I did for higher order funcs) :/
		> read a bit more, still not really getting closer to figuring out how to approach this. Peeked at some future stages and I don't think skipping ahead even temporarily will work, need to barrel through.
		> learnings/realizations from today's chat: scope maps varname to boolean, not var value. Bool indicates whether the var has been initialized but not clear to me yet when vars are not initialized. Asked gpt for some pseudocode as an illustrative tool and seems like I will need to implement a new resolve() method for each statement/expr/decl subclass. That at least gives me some direction to fumble around in.
		> Basically just translating book code to python for this substage, don't think I'm going to reason my way to understanding - need to just implement and build up understanding from there. Started resolver class and wrote resolve methods for Block and Statement.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/16/25 sat
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	-resolve method for (not super confident in which need it at this point but this is my impression):
		X -VariableDeclaration
			> ended up writing ("translating") new declare and define methods for Resolver.
		-Expression
		-others?
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/17/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	-resolve method for (not super confident in which need it at this point but this is my impression):
		X -Expression (Variable?)
		-others?
			> looks like I need to do Assign (or something for var assignment)
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/18/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	~ -resolve method for (not super confident in which need it at this point but this is my impression):
		X -Assign
		X -function declarations
		X -others?
			> turns out we do need a resolve method for all expr/statement classes but most were super simple. Haven't done one for LoxCallable or LoxFunction yet bc book didn't but can confirm next time.
	-make use of resolver somehow? (like I've defined a bunch of methods but need to actually start the chain somewhere)
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions

8/19/25 tues
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	X -confirm whether LoxFunction and/or LoxCallable need resolve methods
		> LoxCallable is never directly instantiated. LoxFunction is, as is NativeClock. gpt claims I don't need a resolve method for LoxFunction bc it's a runtime obj and by the time we call it, resolution is done. So I think that applies to its parents/siblings as well.
	~ -make use of resolver somehow? (I've defined a bunch of methods but need to actually start the chain somewhere. Think this is what book section 11.4 does)
		> UPDATE: new Interpreter.resolve method, tentatively updated how Variable gets resolved (implemented in Token.evaluate). Need to define new Environment.read_state_at method, see book for help.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/20/25 wed
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: new Interpreter.resolve method, tentatively updated how Variable gets resolved (implemented in Token.evaluate). Initially thought I had to update all expr/stmt evaluate methods but actually sounds like maybe unnecessary bc my Token.evaluate update handles all that?
	X -Environment.read_state_at method (see book for help)
		> also wrote update_state_at method. Book does something with globals, don't think I've implemented that yet and not totally clear what that consists of. But can get to it when it comes up.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/21/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: need to figure out where/how to run resolver.resolve(statements). Seems like book expects us to run parse and then run separately, but I've been doing either/or. Also parse and run both fail now on the open test case, argh, probably broke a ton of stuff with this section's changes.
	~ -figure out where/how to call resolver.resolve()
		> working on it, refactoring top level logic in main a bit. Still WIP.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/22/25 fri
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: need to figure out where/how to run resolver.resolve(statements). Seems like book expects us to run parse and then run separately, but I've been doing either/or. Also parse and run both fail now on the open test case, argh, probably broke a ton of stuff with this section's changes.
	-finish updating command-calling logic in main (do we always want to resolve?)
	~ -debug why parse is now failing
		> parse fails even for pretty simple function call now. Tried checking out stable commit and makefile parsing tests pass but make parse on current test case still fails, even when simplified to basic function call. Weird.
		> see notes in parser.py, need to figure out why call() is running on just semicolon alone after parsing a function call rather than attaching the semicolon to the preceding expr. May need to chat a bit about expected behavior.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/23/25 sat
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: need to figure out where/how to run resolver.resolve(statements). Seems like book expects us to run parse and then run separately, but I've been doing either/or. Also parse and run both fail now on the open test case, argh, probably broke a ton of stuff with this section's changes.
	X -debug why parse is now failing
		> see notes in parser.py, need to figure out why call() is running on just semicolon alone after parsing a function call rather than attaching the semicolon to the preceding expr. May need to chat a bit about expected behavior.
		> update: not 100% sure this is right but makefile tests still pass and now the test case appears to parse correctly. Issue was that I returned early before checking semicolons in parse mode which caused us to attempt to parse the semicolon again as its own expression, bc we never incremented index past it. That should now be resolved.
	-finish updating command-calling logic in main (do we always want to resolve?)
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/24/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: make parse seems ok now, now try to get make run working.
	~ -get make run working on open test case
		> getting closer, runs without error now (though not yet working). Added an interpreter.resolve_all method, previously was using resolver.resolve here but that's not what I wanted. Think the issue is that I never implemented handling for globals.
	-ui tests pass
		-0
		-1
		-2
		-3
		-4
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/25/25 mon
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> status: make parse seems ok now, now try to get make run working.
	X -get make run working on open test case
		> recall: variable isn't getting defined/declared by resolve_local, I think bc it's a global?
		X -add handling for globals (see comment above resolve_local and book section)
		X -try rm resolver.record_depth and use INTERPRETER.resolve instead? (sounds like this is the intended way; resolver.depths should not be needed)
		X -test passes
	-ui tests pass
		> regular function and func inside block work now. Nested functions seemingly do not yet.
		X -0
		X -1
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/26/25 tues
------------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	~ -ui tests pass
		> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
		> eek, getting a bit lost. Decided one clue might be that issue I had flagged about resolver.resolve always creating a new scope, revised things a bit and I *think* we are creating the correct number of scopes now, though overall we still error out as before.
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/27/25 wed
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
	> Decided one clue might be that issue I had flagged about resolver.resolve always creating a new scope, revised things a bit and I *think* we are creating the correct number of scopes now, though overall we still error out as before.
	! -review latest logs and try to determine why makeCounter makes it into locals but counter does not
		> debugged a bit, not making huge progress. Decided to just comb through the book code again to make sure all my functions are implemented correctly. Think I found one error in resolve_local though it did not visibly affect results yet. Got through 11.3.4 and feel reasonably confident about the stuff preceding that. Next is 11.3.5 and resolve_function, really hoping the issue is there.
	-ui tests pass
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/28/25 thurs
-------------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
	> Recall: combing through book to check my implementation func by func.
	X -check resolve implementations vs book one by one (resume with: 11.3.5, resolve_function)
		> finished combing through 11.3.5 and everything seems fine, I did re-enable new scope creation in resolve_function which I *believe* matches book behavior, does mean we're back to what gpt told me was the wrong number of new scope creations but I'm growing a bit skeptical about whether that was actually correct. Bit stuck, maybe need to brainstorm new approaches to debugging this.
	-ui tests pass
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/30/25 sat
-----------
-low effort tasks:
	X -brainstorm new debugging approaches to this resolution stuff
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
	-new resolution approaches:
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
		! -look for codecrafters forum discussions
		X -look for random online lox discussions
		-[add more here]
			-try simpler test case (e.g. func in block vs func in func in block) and slowly add back in complexity (actually I guess test case 1 already does this)
			-try to skip resolution and move on for now (supposedly not a great idea but could test that claim)
			~ -more standard-ish debugging: print in resolve_local what all the resolved depths are (noticing a lot of 0s in my scopes dict 🤔)
				> confirmed we're currently only resolving depth to 0. Need to confirm but I don't think that's correct.
			~ -look for a working implementation online (perhaps whatever is being used in the original tests repo? Recall it cloned something and seemingly ran tests against that when I first cloned it)
				> found a couple versions in other language. Kind of nice that it's not python, feels less like cheating.
	-ui tests pass
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

8/31/25 sun
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution (new stage! and new section, resolving & binding!)
	> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
	-new resolution approaches:
		-more standard-ish debugging:
			X -chat to confirm that not all depths should be resolved to 0 for current test case (more generally, need better understanding of what these depths are - I think it's # of steps from global env but confirm)
				> all 0s is actually correct (seemingly) BUT uncovered a big bug where return statements could be unintentionally empty (returning null). Fixed that and the counter variable not found error disappeared, though output is still wrong. Wrong in kind of a weird way actually: I would have expected 1/1/1 (always reference the global and never update it) or 1/2/1 (erroneously switch to referencing the local var once it's defined) but we get 1/2/2.
			X -confirm if expected that depths are only set (i.e. interpreter.resolve is only called) in resolve_local (so only Variable(Definition) and Assign call it)
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	-ui tests pass
		-2
		-3
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		-scanning
		-parsing
		-evaluation
		-statements
		-control_flow
		-functions
	-go back and try to understand wth we just did in this stage

9/1/25 mon
----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution
	> next step is to get nested funcs working. Regular func and func in block work, but not func in func.
	> status: fixed counter var not found error, but output is still wrong in kind of a weird way: I would have expected 1/1/1 (always reference the global and never update it) or 1/2/1 (erroneously switch to referencing the local var once it's defined) but we get 1/2/2.
	X -investigate what is causing 1/2/2 printed output (which count var are we referencing at each point? Which env is that in and what does its state look like at that point?)
	-prob need to refactor so that Interpreter.resolve uses objects as keys instead of strings? (Also will need to figure out how this will work since I recreate objects when time to run 😬)
	-other debugging options for if I get badly stuck again:
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	X -ui tests pass
		X -2
		X -3
		X -(once 3 passes) check that 1 still passes
	-`make test_resolving_w_jlox` stage 1/4 pass
	-prev rounds' tests still pass
		X -scanning
		X -parsing
		X -evaluation
		! -statements
			> 💀 stage 410 test 4 fails now (one of those "modified foo, inner baz, modified foo" ones but I now print "outer foo" for the last one)
		X -control_flow
		! -functions
			> 😭 stage 602 test 4 now fails with "undefined variable i"
	-go back and try to understand wth we just did in this stage

9/2/25 tues
-----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution
	> status: got ui tests passing but broke some previous rounds test cases 😭
	-fix prev rounds' tests
		~ -statements
			> 💀 stage 410 test 4 fails now (one of those "modified foo, inner baz, modified foo" ones but I now print "outer foo" for the last one)
			> update: looks like this is due to the str key issue mentioned a couple bullets below. See misct.txt.
		-functions
			> 😭 stage 602 test 4 now fails with "undefined variable i"
	-prob need to refactor so that Interpreter.resolve uses objects as keys instead of strings? (Also will need to figure out how this will work since I recreate objects when time to run 😬)
	-other debugging options for if I get badly stuck again:
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	-`make test_resolving_w_jlox` stage 1/4 pass
	-go back and try to understand wth we just did in this stage

9/3/25 wed
----------
-low effort tasks:
    -add more low effort task bullets
-stage #67: identifier resolution
	> status: got ui tests passing but broke some previous rounds test cases
	X -refactor so that Interpreter.resolve uses objects as keys instead of strings (Also will need to figure out how this will work since I recreate objects when time to run 😬)
		> looks like this is causing the stage 410 failure mentioned below. See misc.txt for more notes.
	~ -fix prev rounds' tests
		X -statements
			> stage 410 test 4 fails now (open in subl or see bash cmd history).
		-functions
			> 😭 stage 602 test 4 now fails with "undefined variable i"
			> 9/3 update: 602.4 now passes, 603.1 is the first failure.
	-other debugging options for if I get badly stuck again:
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	-`make test_resolving_w_jlox` stage 1/4 pass
	-go back and try to understand wth we just did in this stage

9/4/25 thurs
------------
-low effort tasks:
	-tons of comments to clean up from testing my obj keys (vs strs) in interpreter.locals
    -add more low effort task bullets
-stage #67: identifier resolution
	> status: fixed `statements` tests and more `functions` tests pass, but functions 603.1 still fails. test_case_2.lox has it loaded.
	-fix prev rounds' tests
		-functions
			X -fix 603.1 (yikes, looks like args are no longer available in func env)
			~ -fix any other tests if they fail too
				> 608.3 failed, Call.evaluate did not accept 'env' var. I fixed that (just allow unused kwargs 🤷‍♂️). But 609.1 fails now (closures 😬).
	-other debugging options for if I get badly stuck again:
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	-`make test_resolving_w_jlox` stage 1/4 pass
	-run all prev `make test...` rounds again (high risk of breaking something with each of these fixes)
	-go back and try to understand wth we just did in this stage

9/5/25 fri
----------
-low effort tasks:
	-tons of comments to clean up from testing my obj keys (vs strs) in interpreter.locals
    -add more low effort task bullets
-stage #67: identifier resolution
	> status: fixed a few problems with function scopes, now every functions substage passes except closures.
	-fix prev rounds' tests
		-functions
			-fix 609.1 (in test_case_2.lox)
			-fix any other tests if they fail too
	-other debugging options for if I get badly stuck again:
		-look through online implementations resolution sections to try to find where I'm going wrong
		-show cursor/claude code the whole repo rather than janky gpt snippet chat
	-`make test_resolving_w_jlox` stage 1/4 pass
	-run all prev `make test...` rounds again (high risk of breaking something with each of these fixes)
	-go back and try to understand wth we just did in this stage
